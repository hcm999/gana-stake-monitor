<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GANAæ•°æ®ç®¡ç†åå° Â· ç®¡ç†å‘˜</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- ä½¿ç”¨ ethers v5 ç‰ˆæœ¬ï¼Œä¸ä¹‹å‰çš„ä»£ç å…¼å®¹ -->
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body { 
            background-color: #0f172a; 
            color: #e2e8f0; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .login-panel {
            background: linear-gradient(145deg, #1e293b, #0f172a);
            border: 2px solid #334155;
            border-radius: 32px;
            padding: 40px;
            max-width: 400px;
            margin: 100px auto;
            text-align: center;
        }
        
        .login-panel h2 {
            color: #e2e8f0;
            margin-bottom: 30px;
            font-size: 1.8rem;
        }
        
        .login-panel input {
            width: 100%;
            padding: 15px;
            background: #0f172a;
            border: 2px solid #334155;
            border-radius: 30px;
            color: #e2e8f0;
            font-size: 1rem;
            margin-bottom: 20px;
            outline: none;
        }
        
        .login-panel input:focus {
            border-color: #3b82f6;
        }
        
        .login-panel button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border: none;
            border-radius: 30px;
            color: white;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .login-panel button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(59,130,246,0.3);
        }
        
        .admin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(145deg, #1e293b, #0f172a);
            border-radius: 16px;
            border: 1px solid #334155;
        }
        
        .admin-header h1 {
            font-size: 1.8rem;
            background: linear-gradient(135deg, #60a5fa, #c084fc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin: 0;
        }
        
        .admin-header .badge {
            background: #f59e0b;
            color: white;
            padding: 8px 16px;
            border-radius: 30px;
            font-size: 0.9rem;
        }
        
        .query-panel {
            background: linear-gradient(145deg, #1e293b, #0f172a);
            border: 1px solid #334155;
            border-radius: 16px;
            padding: 20px;
            margin-bottom: 20px;
        }
        
        .query-panel h4 {
            color: #94a3b8;
            margin-bottom: 15px;
        }
        
        .query-panel textarea {
            width: 100%;
            min-height: 150px;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 12px;
            color: #e2e8f0;
            padding: 15px;
            font-family: monospace;
            margin-bottom: 15px;
            resize: vertical;
        }
        
        .query-panel textarea:focus {
            outline: none;
            border-color: #3b82f6;
        }
        
        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border: none;
            padding: 12px 24px;
            border-radius: 30px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            flex: 1;
            min-width: 120px;
            transition: all 0.3s;
        }
        
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(59,130,246,0.3);
        }
        
        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .btn-success {
            background: linear-gradient(135deg, #10b981, #059669);
            border: none;
            padding: 12px 24px;
            border-radius: 30px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            flex: 1;
            transition: all 0.3s;
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16,185,129,0.3);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            border: none;
            padding: 12px 24px;
            border-radius: 30px;
            color: white;
            font-weight: 600;
            cursor: pointer;
            flex: 1;
            transition: all 0.3s;
        }
        
        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(239,68,68,0.3);
        }
        
        .stats-summary {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        
        .stat-item {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }
        
        .stat-label {
            color: #94a3b8;
            font-size: 0.8rem;
            margin-bottom: 5px;
        }
        
        .stat-value {
            color: #38bdf8;
            font-size: 1.4rem;
            font-weight: bold;
        }
        
        .progress-container {
            margin-top: 15px;
            padding: 15px;
            background: #1e293b;
            border-radius: 30px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: #334155;
            border-radius: 4px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            transition: width 0.3s ease;
        }
        
        .github-config {
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .github-config input {
            width: 100%;
            padding: 12px;
            background: #0f172a;
            border: 1px solid #334155;
            border-radius: 30px;
            color: #e2e8f0;
            margin: 8px 0;
            font-size: 0.9rem;
        }
        
        .github-config input:focus {
            outline: none;
            border-color: #3b82f6;
        }
        
        .preview-table {
            max-height: 400px;
            overflow-y: auto;
            background: #1e293b;
            border-radius: 12px;
            padding: 10px;
        }
        
        .preview-table table {
            width: 100%;
            font-size: 0.85rem;
        }
        
        .preview-table th {
            color: #94a3b8;
            padding: 10px 8px;
            text-align: left;
            border-bottom: 1px solid #334155;
        }
        
        .preview-table td {
            padding: 8px;
            border-bottom: 1px solid #334155;
        }
        
        .address-cell {
            color: #60a5fa;
            font-family: monospace;
        }
        
        .badge-duration {
            padding: 4px 12px;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
        }
        
        .badge-1d { background: #3b82f6; color: white; }
        .badge-15d { background: #8b5cf6; color: white; }
        .badge-30d { background: #ec4899; color: white; }
        
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #64748b;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- ç™»å½•é¢æ¿ -->
        <div id="loginPanel" class="login-panel">
            <h2>ğŸ” ç®¡ç†å‘˜ç™»å½•</h2>
            <input type="password" id="adminPassword" placeholder="è¯·è¾“å…¥ç®¡ç†å‘˜å¯†ç " onkeypress="if(event.key==='Enter') adminLogin()">
            <button onclick="adminLogin()">ç™»å½•</button>
        </div>

        <!-- ç®¡ç†é¢æ¿ -->
        <div id="adminPanel" style="display: none;">
            <div class="admin-header">
                <h1>âš™ï¸ GANA æ•°æ®ç®¡ç†åå°</h1>
                <span class="badge">ç®¡ç†å‘˜æ¨¡å¼</span>
            </div>

            <!-- GitHub é…ç½® -->
            <div class="github-config">
                <h4 style="color: #94a3b8; margin-bottom: 15px;">ğŸ“¦ GitHub é…ç½®</h4>
                <input type="text" id="githubOwner" placeholder="GitHubç”¨æˆ·å" value="hcm999">
                <input type="text" id="githubRepo" placeholder="ä»“åº“å" value="gana-stake-data">
                <input type="password" id="githubToken" placeholder="ä¸ªäººè®¿é—®ä»¤ç‰Œ" value="">
                <input type="text" id="githubPath" placeholder="æ–‡ä»¶è·¯å¾„" value="data/stake-data.json">
                <div style="display: flex; gap: 10px; margin-top: 10px;">
                    <button class="btn-primary" onclick="testGithubConnection()" style="flex: 1;">æµ‹è¯•è¿æ¥</button>
                    <button class="btn-primary" onclick="createGithubFolder()" style="flex: 1;">åˆ›å»ºdataæ–‡ä»¶å¤¹</button>
                </div>
            </div>

            <!-- æŸ¥è¯¢é¢æ¿ -->
            <div class="query-panel">
                <h4>ğŸ” é“¾ä¸ŠæŸ¥è¯¢</h4>
                <textarea id="addressList" placeholder="æ¯è¡Œä¸€ä¸ªåœ°å€ï¼Œæœ€å¤š5000ä¸ª">0x72212F35aC448FE7763aA1BFdb360193Fa098E52</textarea>
                
                <div class="button-group">
                    <button class="btn-primary" onclick="fullQuery()" id="fullQueryBtn">ğŸš€ å…¨é‡æŸ¥è¯¢</button>
                    <button class="btn-primary" onclick="incrementalQuery()" id="incrementalBtn">ğŸ”„ å¢é‡æ›´æ–°</button>
                    <button class="btn-primary" onclick="refreshLPPool()" id="refreshLPBtn">ğŸ’§ åˆ·æ–°LPæ± </button>
                </div>

                <!-- è¿›åº¦æ¡ -->
                <div id="progressContainer" class="progress-container" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill" style="width: 0%;"></div>
                    </div>
                    <div style="color: #38bdf8; font-size: 0.9rem; margin-top: 8px; text-align: center;" id="progressText">å‡†å¤‡æŸ¥è¯¢...</div>
                </div>

                <!-- ç»Ÿè®¡æ‘˜è¦ -->
                <div class="stats-summary">
                    <div class="stat-item">
                        <div class="stat-label">æ€»è´¨æŠ¼ (USDT)</div>
                        <div class="stat-value" id="statTotal">0.00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">æ´»è·ƒè®°å½•</div>
                        <div class="stat-value" id="statCount">0</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">LPæ± ä½™é¢</div>
                        <div class="stat-value" id="statLP">0.00</div>
                    </div>
                    <div class="stat-item">
                        <div class="stat-label">åœ°å€æ•°</div>
                        <div class="stat-value" id="statAddresses">0</div>
                    </div>
                </div>
            </div>

            <!-- æ“ä½œæŒ‰é’®ç»„ -->
            <div class="button-group">
                <button class="btn-success" onclick="uploadToGithub()">ğŸ“¤ ä¸Šä¼ åˆ° GitHub</button>
                <button class="btn-primary" onclick="loadFromGithub()">ğŸ“¥ ä» GitHub åŠ è½½</button>
                <button class="btn-danger" onclick="resetData()">ğŸ—‘ï¸ é‡ç½®æ•°æ®</button>
            </div>

            <!-- æ•°æ®é¢„è§ˆ -->
            <div class="query-panel">
                <h4>ğŸ‘ï¸ æ•°æ®é¢„è§ˆ (æœ€æ–°20æ¡)</h4>
                <div class="preview-table" id="previewArea">
                    <table>
                        <thead>
                            <tr>
                                <th>åœ°å€</th>
                                <th>é‡‘é¢</th>
                                <th>å‘¨æœŸ</th>
                                <th>çŠ¶æ€</th>
                                <th>è´¨æŠ¼æ—¶é—´</th>
                            </tr>
                        </thead>
                        <tbody id="previewBody">
                            <tr><td colspan="5" class="empty-state">æš‚æ— æ•°æ®</td></tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ================= é…ç½® =================
        const ADMIN_PASSWORD = "admin9120"; // è¯·ä¿®æ”¹ä¸ºä½ è‡ªå·±çš„å¯†ç 
        
        const CONFIG = {
            STAKING: "0x72212F35aC448FE7763aA1BFdb360193Fa098E52",
            LP_POOL: "0xa2f464a2462aed49b9b31eb8861bc6b0bbb0483f",
            USDT: "0x55d398326f99059fF775485246999027B3197955",
            MAX_ADDRESSES: 5000,
            BATCH_SIZE: 10,
            PARALLEL_BATCHES: 2,
            RETRY_LIMIT: 3,
            RETRY_DELAY: 1000
        };

        // ABI
        const ABI_STAKING = [{"inputs":[{"internalType":"address","name":"marketingAddress_","type":"address"},{"internalType":"address","name":"devAddress_","type":"address"},{"internalType":"address","name":"threesevenAddress_","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"inputs":[{"internalType":"uint256","name":"x","type":"uint256"},{"internalType":"uint256","name":"y","type":"uint256"}],"name":"PRBMath_MulDiv18_Overflow","type":"error"},{"inputs":[{"internalType":"uint256","name":"x","type":"uint256"},{"internalType":"uint256","name":"y","type":"uint256"},{"internalType":"uint256","name":"denominator","type":"uint256"}],"name":"PRBMath_MulDiv_Overflow","type":"error"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"reward","type":"uint256"},{"indexed":false,"internalType":"uint40","name":"timestamp","type":"uint40"},{"indexed":false,"internalType":"uint256","name":"index","type":"uint256"}],"name":"RewardPaid","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"user","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"timestamp","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"index","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"stakeTime","type":"uint256"}],"name":"Staked","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[],"name":"GANA","outputs":[{"internalType":"contract IGANA","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"MIN_STAKE_USDT","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"back_Fee","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"account","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"balance","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"balances","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"devAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"isPreacher","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"market_Fee","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"marketingAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"maxStakeAmount","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"network1In","outputs":[{"internalType":"uint256","name":"value","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"},{"internalType":"uint8","name":"index","type":"uint8"}],"name":"principalPlusRewardOfSlot","outputs":[{"internalType":"uint256","name":"reward","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"ratePerSec","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"_gana","type":"address"}],"name":"setGANA","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint160","name":"_amount","type":"uint160"},{"internalType":"uint256","name":"amountOutMin","type":"uint256"},{"internalType":"uint8","name":"_stakeIndex","type":"uint8"}],"name":"stake","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"user","type":"address"}],"name":"stakeCount","outputs":[{"internalType":"uint256","name":"count","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"sync","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"","type":"uint256"}],"name":"t_supply","outputs":[{"internalType":"uint40","name":"stakeTime","type":"uint40"},{"internalType":"uint160","name":"tamount","type":"uint160"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"threesevenAddress","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"threeseven_Fee","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"index","type":"uint256"}],"name":"unstake","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"userIndex","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"uint256","name":"","type":"uint256"}],"name":"userStakeRecord","outputs":[{"internalType":"uint40","name":"stakeTime","type":"uint40"},{"internalType":"uint160","name":"amount","type":"uint160"},{"internalType":"bool","name":"status","type":"bool"},{"internalType":"uint8","name":"stakeIndex","type":"uint8"}],"stateMutability":"view","type":"function"}];

        const USDT_ABI = [
            "function balanceOf(address account) view returns (uint256)",
            "function decimals() view returns (uint8)"
        ];

        const STAKE_DURATIONS = {0: 86400, 1: 1296000, 2: 2592000};
        const STAKE_DURATION_LABELS = {0: "1å¤©", 1: "15å¤©", 2: "30å¤©"};

        // ================= å…¨å±€å˜é‡ =================
        let stakingContract;
        let isQuerying = false;
        let failedAddresses = [];
        let addressCache = new Map();
        let recordCache = new Map();
        let queryResults = [];
        let allStakeRecords = [];
        let lastAddressList = '';
        
        let stats = {
            totalStaked: 0, totalStaked1d: 0, totalStaked15d: 0, totalStaked30d: 0,
            count1d: 0, count15d: 0, count30d: 0,
            unlock2d: 0, unlock7d: 0, unlock15d: 0,
            lpWithdrawable: 0
        };

        // ================= é¡µé¢åŠ è½½åˆå§‹åŒ– =================
        window.addEventListener('load', function() {
            console.log('é¡µé¢åŠ è½½å®Œæˆ');
            // ç¡®ä¿ç™»å½•é¢æ¿æ˜¾ç¤º
            document.getElementById('loginPanel').style.display = 'block';
        });

        // ================= ç®¡ç†å‘˜ç™»å½• =================
        function adminLogin() {
            const pwd = document.getElementById('adminPassword').value;
            if (pwd === ADMIN_PASSWORD) {
                document.getElementById('loginPanel').style.display = 'none';
                document.getElementById('adminPanel').style.display = 'block';
                initContract();
                loadLastData();
                updateAddressCount();
            } else {
                alert('âŒ å¯†ç é”™è¯¯');
            }
        }

        // ================= æ›´æ–°åœ°å€è®¡æ•° =================
        function updateAddressCount() {
            const text = document.getElementById('addressList').value;
            const addresses = text.split('\n')
                .map(l => l.trim())
                .filter(l => l.startsWith('0x') && l.length === 42);
            document.getElementById('statAddresses').innerText = addresses.length;
        }

        // ================= åˆå§‹åŒ–åˆçº¦ =================
        async function initContract() {
            try {
                const provider = new ethers.providers.JsonRpcProvider('https://bsc-dataseed1.binance.org');
                stakingContract = new ethers.Contract(CONFIG.STAKING, ABI_STAKING, provider);
                console.log('âœ… åˆçº¦åˆå§‹åŒ–æˆåŠŸ');
            } catch (error) {
                console.error('âŒ åˆçº¦åˆå§‹åŒ–å¤±è´¥:', error);
                alert('åˆçº¦åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é‡è¯•');
            }
        }

        // ================= ä»GitHubåŠ è½½ä¸Šæ¬¡æ•°æ® =================
        async function loadLastData() {
            const owner = document.getElementById('githubOwner').value;
            const repo = document.getElementById('githubRepo').value;
            const path = document.getElementById('githubPath').value;
            
            if (!owner || owner === 'ä½ çš„GitHubç”¨æˆ·å') {
                console.log('è¯·å…ˆé…ç½®GitHubç”¨æˆ·å');
                return;
            }
            
            try {
                const response = await fetch(`https://raw.githubusercontent.com/${owner}/${repo}/main/${path}?t=${Date.now()}`);
                if (response.ok) {
                    const data = await response.json();
                    queryResults = data.queryResults || [];
                    allStakeRecords = data.allStakeRecords || [];
                    stats = data.stats || stats;
                    updatePreview();
                    updateStats();
                    console.log('âœ… ä»GitHubåŠ è½½æ•°æ®æˆåŠŸ');
                }
            } catch (e) {
                console.log('æ— å†å²æ•°æ®æˆ–åŠ è½½å¤±è´¥');
            }
        }

        // ================= æµ‹è¯•GitHubè¿æ¥ =================
        async function testGithubConnection() {
            const token = document.getElementById('githubToken').value;
            if (!token) {
                alert('è¯·è¾“å…¥GitHub Token');
                return;
            }

            try {
                const response = await fetch('https://api.github.com/user', {
                    headers: { 'Authorization': `token ${token}` }
                });
                if (response.ok) {
                    const user = await response.json();
                    alert(`âœ… GitHubè¿æ¥æˆåŠŸï¼æ¬¢è¿ ${user.login}`);
                } else {
                    alert('âŒ è¿æ¥å¤±è´¥ï¼Œè¯·æ£€æŸ¥Token');
                }
            } catch (error) {
                alert('âŒ è¿æ¥å¤±è´¥: ' + error.message);
            }
        }

        // ================= åˆ›å»ºGitHubæ–‡ä»¶å¤¹ =================
        async function createGithubFolder() {
            const token = document.getElementById('githubToken').value;
            const owner = document.getElementById('githubOwner').value;
            const repo = document.getElementById('githubRepo').value;

            if (!token || !owner || !repo) {
                alert('è¯·å¡«å†™å®Œæ•´çš„GitHubé…ç½®');
                return;
            }

            try {
                // åˆ›å»ºä¸€ä¸ªç©ºçš„ .gitkeep æ–‡ä»¶æ¥åˆ›å»ºæ–‡ä»¶å¤¹
                const content = btoa('');
                
                const response = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/data/.gitkeep`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${token}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: 'åˆ›å»º data æ–‡ä»¶å¤¹',
                        content: content
                    })
                });

                if (response.ok) {
                    alert('âœ… data æ–‡ä»¶å¤¹åˆ›å»ºæˆåŠŸï¼');
                } else {
                    const error = await response.json();
                    alert(`âŒ åˆ›å»ºå¤±è´¥: ${error.message}`);
                }
            } catch (error) {
                alert('âŒ åˆ›å»ºå¤±è´¥: ' + error.message);
            }
        }

        // ================= ä¸Šä¼ åˆ°GitHub =================
        async function uploadToGithub() {
            const token = document.getElementById('githubToken').value;
            const owner = document.getElementById('githubOwner').value;
            const repo = document.getElementById('githubRepo').value;
            const path = document.getElementById('githubPath').value;

            if (!token || !owner || !repo) {
                alert('è¯·å¡«å†™å®Œæ•´çš„GitHubé…ç½®');
                return;
            }

            if (queryResults.length === 0) {
                alert('æ²¡æœ‰æ•°æ®å¯ä¸Šä¼ ');
                return;
            }

            const data = {
                lastUpdate: new Date().toISOString(),
                stats: stats,
                queryResults: queryResults,
                allStakeRecords: allStakeRecords,
                addressCount: queryResults.length,
                totalRecords: allStakeRecords.length
            };

            try {
                // è·å–å½“å‰æ–‡ä»¶ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                let sha = null;
                const getResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
                    headers: { 'Authorization': `token ${token}` }
                });
                
                if (getResponse.ok) {
                    const file = await getResponse.json();
                    sha = file.sha;
                }

                // ä¸Šä¼ æ–°æ•°æ®
                const content = btoa(unescape(encodeURIComponent(JSON.stringify(data, null, 2))));
                
                const uploadResponse = await fetch(`https://api.github.com/repos/${owner}/${repo}/contents/${path}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${token}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        message: `æ›´æ–°è´¨æŠ¼æ•°æ® ${new Date().toLocaleString()}`,
                        content: content,
                        sha: sha
                    })
                });

                if (uploadResponse.ok) {
                    alert('âœ… æ•°æ®ä¸Šä¼ æˆåŠŸï¼');
                } else {
                    const error = await uploadResponse.json();
                    alert(`âŒ ä¸Šä¼ å¤±è´¥: ${error.message}`);
                }
            } catch (error) {
                console.error('ä¸Šä¼ å¤±è´¥:', error);
                alert('âŒ ä¸Šä¼ å¤±è´¥: ' + error.message);
            }
        }

        // ================= ä»GitHubåŠ è½½ =================
        async function loadFromGithub() {
            const owner = document.getElementById('githubOwner').value;
            const repo = document.getElementById('githubRepo').value;
            const path = document.getElementById('githubPath').value;

            try {
                const response = await fetch(`https://raw.githubusercontent.com/${owner}/${repo}/main/${path}?t=${Date.now()}`);
                if (response.ok) {
                    const data = await response.json();
                    queryResults = data.queryResults || [];
                    allStakeRecords = data.allStakeRecords || [];
                    stats = data.stats || stats;
                    updatePreview();
                    updateStats();
                    alert('âœ… åŠ è½½æˆåŠŸ');
                } else {
                    alert('âŒ åŠ è½½å¤±è´¥');
                }
            } catch (error) {
                alert('âŒ åŠ è½½å¤±è´¥: ' + error.message);
            }
        }

        // ================= é‡ç½®æ•°æ® =================
        function resetData() {
            if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰æ•°æ®å—ï¼Ÿ')) {
                queryResults = [];
                allStakeRecords = [];
                addressCache.clear();
                recordCache.clear();
                stats = {
                    totalStaked: 0, totalStaked1d: 0, totalStaked15d: 0, totalStaked30d: 0,
                    count1d: 0, count15d: 0, count30d: 0,
                    unlock2d: 0, unlock7d: 0, unlock15d: 0,
                    lpWithdrawable: 0
                };
                updatePreview();
                updateStats();
            }
        }

        // ================= æ›´æ–°é¢„è§ˆ =================
        function updatePreview() {
            document.getElementById('statTotal').innerText = stats.totalStaked.toFixed(2);
            document.getElementById('statCount').innerText = queryResults.length;
            document.getElementById('statLP').innerText = stats.lpWithdrawable.toFixed(2);
            
            const previewBody = document.getElementById('previewBody');
            if (queryResults.length === 0) {
                previewBody.innerHTML = '<tr><td colspan="5" class="empty-state">æš‚æ— æ•°æ®</td></tr>';
                return;
            }

            previewBody.innerHTML = queryResults.slice(0, 20).map(r => {
                const stakeTime = new Date(r.stakeTime * 1000).toLocaleString();
                return `
                <tr>
                    <td class="address-cell">${r.address.slice(0, 6)}...${r.address.slice(-4)}</td>
                    <td>${r.amount.toFixed(2)}</td>
                    <td><span class="badge-duration badge-${r.stakeIndex === 0 ? '1d' : r.stakeIndex === 1 ? '15d' : '30d'}">${STAKE_DURATION_LABELS[r.stakeIndex]}</span></td>
                    <td>${r.isRedeemed ? 'å·²èµå›' : 'æ´»è·ƒ'}</td>
                    <td>${stakeTime}</td>
                </tr>`;
            }).join('');
        }

        function updateStats() {
            document.getElementById('statTotal').innerText = stats.totalStaked.toFixed(2);
            document.getElementById('statCount').innerText = queryResults.length;
            document.getElementById('statLP').innerText = stats.lpWithdrawable.toFixed(2);
        }

        // ================= å¸¦é‡è¯•çš„åˆçº¦è°ƒç”¨ =================
        async function callWithRetry(fn, context, retryCount = 0) {
            try {
                return await fn();
            } catch (error) {
                if (retryCount < CONFIG.RETRY_LIMIT) {
                    console.log(`è°ƒç”¨å¤±è´¥ï¼Œç¬¬ ${retryCount + 1} æ¬¡é‡è¯•...`, error);
                    await new Promise(resolve => setTimeout(resolve, CONFIG.RETRY_DELAY * (retryCount + 1)));
                    return callWithRetry(fn, context, retryCount + 1);
                } else {
                    console.error(`è°ƒç”¨å¤±è´¥ï¼Œå·²é‡è¯• ${CONFIG.RETRY_LIMIT} æ¬¡:`, error);
                    throw error;
                }
            }
        }

        // ================= è·å–LPæ± USDTä½™é¢ =================
        async function getLPPoolBalance() {
            try {
                const usdtContract = new ethers.Contract(CONFIG.USDT, USDT_ABI, stakingContract.provider);
                const balance = await callWithRetry(
                    () => usdtContract.balanceOf(CONFIG.LP_POOL),
                    "LP Pool USDT balanceOf"
                );
                const formattedBalance = parseFloat(ethers.utils.formatUnits(balance, 18));
                return formattedBalance;
            } catch (error) {
                console.error("è·å–LPæ± USDTä½™é¢å¤±è´¥:", error);
                return 0;
            }
        }

        // ================= åˆ·æ–°LPæ± ä½™é¢ =================
        async function refreshLPPool() {
            if (!stakingContract) {
                alert("âŒ åˆçº¦æœªåˆå§‹åŒ–");
                return;
            }
            
            try {
                document.getElementById('refreshLPBtn').disabled = true;
                document.getElementById('refreshLPBtn').innerText = 'åˆ·æ–°ä¸­...';
                
                const lpBalance = await getLPPoolBalance();
                stats.lpWithdrawable = lpBalance;
                updatePreview();
                updateStats();
                
                document.getElementById('refreshLPBtn').innerText = 'ğŸ’§ åˆ·æ–°LPæ± ';
                document.getElementById('refreshLPBtn').disabled = false;
                
                alert(`âœ… LPæ± ä½™é¢å·²åˆ·æ–°: ${lpBalance.toFixed(2)} USDT`);
            } catch (error) {
                console.error("åˆ·æ–°LPæ± ä½™é¢å¤±è´¥:", error);
                alert("âŒ åˆ·æ–°å¤±è´¥");
                document.getElementById('refreshLPBtn').innerText = 'ğŸ’§ åˆ·æ–°LPæ± ';
                document.getElementById('refreshLPBtn').disabled = false;
            }
        }

        // ================= æŸ¥è¯¢å•ä¸ªåœ°å€ =================
        async function queryAddress(address, now, limits) {
            const result = {
                address,
                success: false,
                active: [],
                all: [],
                error: null
            };
            
            try {
                const count = await callWithRetry(
                    () => stakingContract.stakeCount(address),
                    `stakeCount(${address})`
                );
                
                const stakeCount = Number(count);
                addressCache.set(address, { count: stakeCount, lastUpdate: Date.now() });
                
                for (let j = 0; j < stakeCount; j++) {
                    try {
                        const record = await callWithRetry(
                            () => stakingContract.userStakeRecord(address, j),
                            `userStakeRecord(${address}, ${j})`
                        );
                        
                        const stakeTime = Number(record[0]);
                        const amount = record[1];
                        const isRedeemed = record[2];
                        const stakeIndex = Number(record[3]);
                        const amountNum = parseFloat(ethers.utils.formatUnits(amount, 18));
                        
                        result.all.push({
                            address,
                            amount: amountNum,
                            stakeTime,
                            stakeIndex,
                            isRedeemed
                        });
                        
                        if (!isRedeemed) {
                            const unlockTime = stakeTime + STAKE_DURATIONS[stakeIndex];
                            const timeRemaining = unlockTime - now;
                            
                            result.active.push({
                                address,
                                amount: amountNum,
                                stakeTime,
                                stakeIndex,
                                unlockTime,
                                timeRemaining,
                                isRedeemed
                            });
                            
                            // å®æ—¶æ›´æ–°ç»Ÿè®¡
                            stats.totalStaked += amountNum;
                            
                            if (stakeIndex === 0) {
                                stats.totalStaked1d += amountNum;
                                stats.count1d++;
                            } else if (stakeIndex === 1) {
                                stats.totalStaked15d += amountNum;
                                stats.count15d++;
                            } else if (stakeIndex === 2) {
                                stats.totalStaked30d += amountNum;
                                stats.count30d++;
                            }
                            
                            if (unlockTime <= limits['2d']) stats.unlock2d += amountNum;
                            if (unlockTime <= limits['7d']) stats.unlock7d += amountNum;
                            if (unlockTime <= limits['15d']) stats.unlock15d += amountNum;
                        }
                    } catch (e) {
                        console.log(`è¯»å–è®°å½•å¤±è´¥: ${address}[${j}]`, e);
                    }
                }
                
                result.success = true;
                
            } catch (e) {
                console.log(`æŸ¥è¯¢åœ°å€å¤±è´¥: ${address}`, e);
                result.error = e.message;
                failedAddresses.push(address);
            }
            
            return result;
        }

        // ================= å…¨é‡æŸ¥è¯¢ =================
        async function fullQuery() {
            if (!stakingContract) {
                alert("âŒ åˆçº¦æœªåˆå§‹åŒ–");
                return;
            }
            
            if (isQuerying) return;

            const text = document.getElementById('addressList').value;
            const addresses = text.split('\n')
                .map(l => l.trim())
                .filter(l => l.startsWith('0x') && l.length === 42);
            
            if (addresses.length === 0) {
                alert("âŒ æ²¡æœ‰æœ‰æ•ˆåœ°å€");
                return;
            }
            
            if (addresses.length > CONFIG.MAX_ADDRESSES) {
                alert(`âŒ æœ€å¤š ${CONFIG.MAX_ADDRESSES} ä¸ªåœ°å€`);
                return;
            }

            isQuerying = true;
            failedAddresses = [];
            lastAddressList = text;
            
            document.getElementById('incrementalBtn').disabled = true;
            document.getElementById('fullQueryBtn').disabled = true;
            document.getElementById('progressContainer').style.display = 'block';

            // é‡ç½®æ‰€æœ‰æ•°æ®
            queryResults = [];
            allStakeRecords = [];
            addressCache.clear();
            stats = {
                totalStaked: 0, totalStaked1d: 0, totalStaked15d: 0, totalStaked30d: 0,
                count1d: 0, count15d: 0, count30d: 0,
                unlock2d: 0, unlock7d: 0, unlock15d: 0,
                lpWithdrawable: 0
            };

            // è·å–LPæ± USDTä½™é¢
            try {
                const lpBalance = await getLPPoolBalance();
                stats.lpWithdrawable = lpBalance;
            } catch (error) {
                console.error("è·å–LPæ± USDTä½™é¢å¤±è´¥:", error);
            }

            const now = Math.floor(Date.now() / 1000);
            const limits = {
                '2d': now + 172800,
                '7d': now + 604800,
                '15d': now + 1296000
            };

            let processed = 0;
            let totalActiveRecords = 0;
            let successCount = 0;

            // åˆ†æ‰¹å¤„ç†
            for (let i = 0; i < addresses.length; i += CONFIG.BATCH_SIZE) {
                const batch = addresses.slice(i, i + CONFIG.BATCH_SIZE);
                
                const promises = batch.map(address => queryAddress(address, now, limits));
                const results = await Promise.all(promises);
                
                results.forEach(result => {
                    processed++;
                    if (result.success) {
                        successCount++;
                        queryResults.push(...result.active);
                        allStakeRecords.push(...result.all);
                        totalActiveRecords += result.active.length;
                        
                        // æ›´æ–°ç¼“å­˜
                        result.all.forEach(record => {
                            const key = `${record.address}_${record.stakeTime}`;
                            recordCache.set(key, record);
                        });
                    }
                });

                const progress = Math.round((processed / addresses.length) * 100);
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressText').innerHTML = 
                    `æŸ¥è¯¢ä¸­ ${processed}/${addresses.length} (æˆåŠŸ ${successCount}, æ‰¾åˆ° ${totalActiveRecords} æ¡æ´»è·ƒè®°å½•)`;
                
                updatePreview();
                
                // æ¯æ‰¹æŸ¥è¯¢åç¨å¾®å»¶è¿Ÿ
                await new Promise(r => setTimeout(r, 100));
            }

            // æŒ‰æ—¶é—´å€’åºæ’åº
            queryResults.sort((a, b) => b.stakeTime - a.stakeTime);
            
            updatePreview();
            updateStats();

            let completeMsg = `âœ… å®Œæˆ: ${totalActiveRecords}æ¡æ´»è·ƒè®°å½•`;
            if (failedAddresses.length > 0) {
                completeMsg += `, ${failedAddresses.length}ä¸ªåœ°å€æŸ¥è¯¢å¤±è´¥`;
            }
            document.getElementById('progressText').innerHTML = completeMsg;
            
            setTimeout(() => {
                document.getElementById('incrementalBtn').disabled = false;
                document.getElementById('fullQueryBtn').disabled = false;
                document.getElementById('progressContainer').style.display = 'none';
                isQuerying = false;
            }, 3000);
        }

        // ================= å¢é‡æŸ¥è¯¢ =================
        async function incrementalQuery() {
            if (!stakingContract) {
                alert("âŒ åˆçº¦æœªåˆå§‹åŒ–");
                return;
            }
            
            if (isQuerying) return;

            const text = document.getElementById('addressList').value;
            const addresses = text.split('\n')
                .map(l => l.trim())
                .filter(l => l.startsWith('0x') && l.length === 42);
            
            if (addresses.length === 0) {
                alert("âŒ æ²¡æœ‰æœ‰æ•ˆåœ°å€");
                return;
            }
            
            if (addresses.length > CONFIG.MAX_ADDRESSES) {
                alert(`âŒ æœ€å¤š ${CONFIG.MAX_ADDRESSES} ä¸ªåœ°å€`);
                return;
            }

            isQuerying = true;
            failedAddresses = [];
            lastAddressList = text;
            
            document.getElementById('incrementalBtn').disabled = true;
            document.getElementById('fullQueryBtn').disabled = true;
            document.getElementById('progressContainer').style.display = 'block';

            // æ¸…ç©ºæŸ¥è¯¢ç»“æœï¼Œé‡æ–°æ„å»º
            queryResults = [];
            
            const now = Math.floor(Date.now() / 1000);
            const limits = {
                '2d': now + 172800,
                '7d': now + 604800,
                '15d': now + 1296000
            };

            // è·å–LPæ± USDTä½™é¢
            try {
                const lpBalance = await getLPPoolBalance();
                stats.lpWithdrawable = lpBalance;
            } catch (error) {
                console.error("è·å–LPæ± USDTä½™é¢å¤±è´¥:", error);
            }

            let processed = 0;
            let newRecords = 0;
            let redeemedRecords = 0;
            let successCount = 0;

            // åˆ†æ‰¹å¤„ç†
            for (let i = 0; i < addresses.length; i += CONFIG.BATCH_SIZE) {
                const batch = addresses.slice(i, i + CONFIG.BATCH_SIZE);
                
                const promises = batch.map(async (address) => {
                    let newForAddress = 0;
                    let redeemedForAddress = 0;
                    const addressRecords = [];
                    
                    try {
                        const currentCount = await callWithRetry(
                            () => stakingContract.stakeCount(address),
                            `stakeCount(${address})`
                        );
                        
                        // æŸ¥è¯¢æ‰€æœ‰è®°å½•
                        for (let j = 0; j < Number(currentCount); j++) {
                            try {
                                const record = await callWithRetry(
                                    () => stakingContract.userStakeRecord(address, j),
                                    `userStakeRecord(${address}, ${j})`
                                );
                                
                                const stakeTime = Number(record[0]);
                                const amount = record[1];
                                const isRedeemed = record[2];
                                const stakeIndex = Number(record[3]);
                                const key = `${address}_${stakeTime}`;
                                const amountNum = parseFloat(ethers.utils.formatUnits(amount, 18));
                                
                                addressRecords.push({
                                    address,
                                    amount: amountNum,
                                    stakeTime,
                                    stakeIndex,
                                    isRedeemed
                                });
                                
                                if (!isRedeemed) {
                                    const unlockTime = stakeTime + STAKE_DURATIONS[stakeIndex];
                                    const timeRemaining = unlockTime - now;
                                    
                                    const recordData = {
                                        address,
                                        amount: amountNum,
                                        stakeTime,
                                        stakeIndex,
                                        unlockTime,
                                        timeRemaining,
                                        isRedeemed
                                    };
                                    
                                    // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°è®°å½•
                                    if (!recordCache.has(key)) {
                                        recordData.isNew = true;
                                        newForAddress++;
                                        
                                        // æ›´æ–°ç»Ÿè®¡
                                        stats.totalStaked += amountNum;
                                        
                                        if (stakeIndex === 0) {
                                            stats.totalStaked1d += amountNum;
                                            stats.count1d++;
                                        } else if (stakeIndex === 1) {
                                            stats.totalStaked15d += amountNum;
                                            stats.count15d++;
                                        } else if (stakeIndex === 2) {
                                            stats.totalStaked30d += amountNum;
                                            stats.count30d++;
                                        }
                                        
                                        if (unlockTime <= limits['2d']) stats.unlock2d += amountNum;
                                        if (unlockTime <= limits['7d']) stats.unlock7d += amountNum;
                                        if (unlockTime <= limits['15d']) stats.unlock15d += amountNum;
                                    }
                                    
                                    queryResults.push(recordData);
                                    recordCache.set(key, recordData);
                                    
                                } else {
                                    // å·²èµå›çš„è®°å½• - æ£€æŸ¥ä¹‹å‰æ˜¯å¦æ´»è·ƒ
                                    if (recordCache.has(key)) {
                                        const oldRecord = recordCache.get(key);
                                        recordCache.delete(key);
                                        redeemedForAddress++;
                                        
                                        // ä»ç»Ÿè®¡ä¸­å‡å»
                                        stats.totalStaked -= oldRecord.amount;
                                        
                                        if (oldRecord.stakeIndex === 0) {
                                            stats.totalStaked1d -= oldRecord.amount;
                                            stats.count1d--;
                                        } else if (oldRecord.stakeIndex === 1) {
                                            stats.totalStaked15d -= oldRecord.amount;
                                            stats.count15d--;
                                        } else if (oldRecord.stakeIndex === 2) {
                                            stats.totalStaked30d -= oldRecord.amount;
                                            stats.count30d--;
                                        }
                                    }
                                }
                            } catch (e) {
                                console.log(`è¯»å–è®°å½•å¤±è´¥: ${address}[${j}]`, e);
                            }
                        }
                        
                        addressCache.set(address, { 
                            count: Number(currentCount), 
                            lastUpdate: Date.now() 
                        });
                        
                        // æ·»åŠ åˆ°æ‰€æœ‰è®°å½•
                        allStakeRecords.push(...addressRecords);
                        
                        successCount++;
                        
                    } catch (e) {
                        console.log(`æŸ¥è¯¢åœ°å€å¤±è´¥: ${address}`, e);
                        failedAddresses.push(address);
                    }
                    
                    return { new: newForAddress, redeemed: redeemedForAddress };
                });

                const results = await Promise.all(promises);
                results.forEach(r => {
                    newRecords += r.new;
                    redeemedRecords += r.redeemed;
                });

                processed += batch.length;
                const progress = Math.min(100, Math.round((processed / addresses.length) * 100));
                document.getElementById('progressFill').style.width = progress + '%';
                document.getElementById('progressText').innerHTML = 
                    `å¢é‡æ›´æ–°: +${newRecords}æ–°, -${redeemedRecords}èµå› (${processed}/${addresses.length})`;
                
                updatePreview();
                
                await new Promise(r => setTimeout(r, 100));
            }

            // é‡æ–°æ’åº
            queryResults.sort((a, b) => b.stakeTime - a.stakeTime);
            
            updatePreview();
            updateStats();

            let completeMsg = `âœ… å®Œæˆ: +${newRecords}æ–°, -${redeemedRecords}èµå›`;
            if (failedAddresses.length > 0) {
                completeMsg += `, ${failedAddresses.length}ä¸ªåœ°å€æŸ¥è¯¢å¤±è´¥`;
            }
            document.getElementById('progressText').innerHTML = completeMsg;
            
            setTimeout(() => {
                document.getElementById('incrementalBtn').disabled = false;
                document.getElementById('fullQueryBtn').disabled = false;
                document.getElementById('progressContainer').style.display = 'none';
                isQuerying = false;
            }, 3000);
        }

        // ç›‘å¬åœ°å€è¾“å…¥å˜åŒ–
        document.getElementById('addressList').addEventListener('input', updateAddressCount);
    </script>
</body>
</html>
